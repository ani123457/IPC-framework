<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>IPC Process Encryption Demo</title>
<style>
body{margin:0;padding:20px;background:#0b1224;color:#fff;font-family:Inter}
.wrap{max-width:1200px;margin:auto}
.grid{display:grid;grid-template-columns:1fr 350px;gap:20px}
.card{background:#182033;padding:16px;border-radius:10px;border:1px solid #26304a}
input,textarea,button{width:100%;padding:10px;margin-top:8px;border-radius:8px;background:#111725;border:1px solid #2c3752;color:white}
.btn{cursor:pointer;font-weight:600}
.btn-primary{background:#60a5fa;color:#02101f;border:none}
.btn-ghost{background:#1c2537;border:none}
.btn-warm{background:linear-gradient(90deg,#f97316,#fb7185);border:none;color:white}
.logs{height:360px;overflow-y:auto;background:#111725;padding:10px;border-radius:8px}
.log-line{padding:8px;background:#1d263c;border-radius:6px;margin-bottom:8px;display:flex;gap:10px}
.log-time{opacity:.6;min-width:70px}
.active-btn{background:linear-gradient(90deg,#60a5fa,#7c3aed)!important;color:#020812!important}
.bar{height:14px;background:#60a5fa;border-radius:8px;margin:5px 0}
</style>
</head>

<body>
<div class="wrap">
<h1>IPC Framework – Secure Process Messaging (AES-GCM)</h1>

<div class="grid">

<main>

<!-- CONTROL PANEL -->
<div class="card">
<h2>Control Panel</h2>

<label>Channel</label>
<input id="channelName" value="chat">

<label>Message</label>
<textarea id="msgPayload" rows="4">{ "text": "Hello Process" }</textarea>

<div style="display:flex;gap:10px;margin-top:10px">
<button id="sendBtn" class="btn btn-primary">Send</button>
<button id="pubBtn" class="btn btn-ghost">Publish</button>
<button id="spawnProcessBtn" class="btn btn-ghost">Start Process</button>
<button id="createKeyBtn" class="btn btn-ghost">Create Key</button>
</div>

<label>Password</label>
<input id="pwd" type="password">

<div style="margin-top:10px;display:flex;align-items:center;gap:8px">
<input type="checkbox" id="encryptToggle">
<label>Encrypt Messages</label>
</div>
</div>

<!-- ACTIONS -->
<div class="card" style="margin-top:20px">
<h3>Actions</h3>

<div style="display:flex;gap:10px;margin-bottom:10px">
<button id="example1" class="btn btn-warm">Send to Process</button>
<button id="example2" class="btn btn-ghost">Broadcast</button>
<button id="example3" class="btn btn-ghost">Subscribe</button>
<button id="clearBtn" class="btn btn-ghost">Clear Logs</button>
</div>

<div id="logs" class="logs"></div>
</div>

</main>

<!-- SIDEBAR -->
<aside class="card">
<h3>Status</h3>
<p>Process: <span id="processStatus">none</span></p>
<p>Channels: <span id="channelsList">-</span></p>

<h3 style="margin-top:20px">Stats</h3>
<div id="statsGraph"></div>
<table id="statsTable" style="width:100%;margin-top:10px">
<tr><td><b>Channel</b></td><td><b>Count</b></td></tr>
</table>
</aside>

</div>
</div>

<script>
/* -------------------------------------------------------
   BASE64 + AES-GCM HELPERS
---------------------------------------------------------*/
function ab2b64(buf){return btoa(String.fromCharCode(...new Uint8Array(buf)))}
function b642ab(b64){return Uint8Array.from(atob(b64),c=>c.charCodeAt(0)).buffer}

async function deriveKey(password){
  const enc=new TextEncoder();
  const salt=enc.encode("ipc-process-salt");
  const base=await crypto.subtle.importKey("raw",enc.encode(password),"PBKDF2",false,["deriveKey"]);
  return crypto.subtle.deriveKey(
    {name:"PBKDF2",salt,iterations:150000,hash:"SHA-256"},
    base,
    {name:"AES-GCM",length:256},
    true,
    ["encrypt","decrypt"]
  );
}

async function encryptText(key,plain){
  const iv=crypto.getRandomValues(new Uint8Array(12));
  const cipher=await crypto.subtle.encrypt({name:"AES-GCM",iv},key,new TextEncoder().encode(plain));
  return {__encrypted:true,data:ab2b64(cipher),iv:ab2b64(iv.buffer)};
}

async function decryptText(key,obj){
  const cipher=b642ab(obj.data);
  const iv=new Uint8Array(b642ab(obj.iv));
  const plain=await crypto.subtle.decrypt({name:"AES-GCM",iv},key,cipher);
  return new TextDecoder().decode(plain);
}

/* -------------------------------------------------------
   LOGGING
---------------------------------------------------------*/
const logs=document.getElementById("logs");
function log(type,msg){
  const el=document.createElement("div");
  el.className="log-line";
  el.innerHTML=`<div class="log-time">${new Date().toLocaleTimeString()}</div>
                <div><b>${type}</b> — ${typeof msg==="string"?msg:JSON.stringify(msg,null,2)}</div>`;
  logs.prepend(el);
}

/* -------------------------------------------------------
   STATS
---------------------------------------------------------*/
const stats={};
function updateStats(ch){
  stats[ch]=(stats[ch]||0)+1;
  const graph=document.getElementById("statsGraph");
  graph.innerHTML="";
  const max=Math.max(...Object.values(stats),1);

  for(const c in stats){
    const bar=document.createElement("div");
    bar.className="bar";
    bar.style.width=(stats[c]/max*100)+"%";
    graph.appendChild(bar);
  }

  const tbl=document.getElementById("statsTable");
  tbl.innerHTML=`<tr><td><b>Channel</b></td><td><b>Count</b></td></tr>`;
  for(const c in stats) tbl.innerHTML+=`<tr><td>${c}</td><td>${stats[c]}</td></tr>`;
}

/* -------------------------------------------------------
   IPC CORE (ENCRYPT + DECRYPT)
---------------------------------------------------------*/
const IPC=(()=>{
  const channels=new Map();
  const subs=new Map();
  const bc=new BroadcastChannel("ipc-process-demo");

  bc.onmessage=e=>handleIncoming(e.data.channel,e.data.payload);

  function createChannel(ch){
    if(!channels.has(ch)) channels.set(ch,[]);
    document.getElementById("channelsList").textContent=[...channels.keys()].join(", ");
  }

  async function send(ch,payload,{encrypt}={}){
    createChannel(ch);

    let out=payload;
    if(encrypt && window._aesKey){
      const plain=typeof payload==="string"?payload:JSON.stringify(payload);
      out=await encryptText(window._aesKey,plain);
    }

    await handleIncoming(ch,out);
    bc.postMessage({channel:ch,payload:out});
  }

  async function handleIncoming(ch,payload){
    createChannel(ch);

    if(payload && payload.__encrypted){
      log("ENCRYPTED",payload);

      if(window._aesKey){
        try{
          const decrypted=await decryptText(window._aesKey,payload);
          let parsed;
          try{parsed=JSON.parse(decrypted);}catch{parsed=decrypted;}

          log("DECRYPTED",parsed);
          channels.get(ch).push(parsed);
          updateStats(ch);
          if(subs.has(ch)) subs.get(ch).forEach(fn=>fn(parsed));
          return;
        }catch(e){
          log("ERROR","Decrypt failed: "+e.message);
          return;
        }
      }

      log("WARN","Encrypted but no key");
      return;
    }

    log("RECV",payload);
    channels.get(ch).push(payload);
    updateStats(ch);
    if(subs.has(ch)) subs.get(ch).forEach(fn=>fn(payload));
  }

  function on(ch,cb){
    createChannel(ch);
    if(!subs.has(ch)) subs.set(ch,new Set());
    subs.get(ch).add(cb);
  }

  return {send,on};
})();

/* -------------------------------------------------------
   PROCESS (WORKER) IMPLEMENTATION
---------------------------------------------------------*/
let processProxy=null;

spawnProcessBtn.onclick=()=>{
  setActive(spawnProcessBtn);

  if(processProxy){log("INFO","Process already running");return;}

  const code=`
    ${ab2b64.toString()}
    ${b642ab.toString()}

    let processKey=null;

    async function decryptWithKey(obj){
      const cipher=b642ab(obj.data);
      const iv=new Uint8Array(b642ab(obj.iv));
      const plain=await crypto.subtle.decrypt({name:"AES-GCM",iv},processKey,cipher);
      return new TextDecoder().decode(plain);
    }

    async function encryptWithKey(plain){
      const iv=crypto.getRandomValues(new Uint8Array(12));
      const cipher=await crypto.subtle.encrypt({name:"AES-GCM",iv},processKey,new TextEncoder().encode(plain));
      return {__encrypted:true,data:ab2b64(cipher),iv:ab2b64(iv.buffer)};
    }

    self.onmessage=async(e)=>{
      const msg=e.data;

      if(msg.type==="set-key"){
        try{
          processKey=await crypto.subtle.importKey("raw",msg.keyRaw,"AES-GCM",true,["encrypt","decrypt"]);
          self.postMessage({type:"key-set"});
        }catch(err){
          self.postMessage({type:"key-error",error:err.message});
        }
        return;
      }

      const ch=msg.channel;
      const payload=msg.payload;

      if(payload && payload.__encrypted){
        if(processKey){
          try{
            const dec=await decryptWithKey(payload);
            let parsed;
            try{parsed=JSON.parse(dec);}catch{parsed=dec;}

            const reply={echo:parsed,info:"processed by process"};
            const enc=await encryptWithKey(JSON.stringify(reply));
            self.postMessage({channel:ch,payload:enc});
          }catch(e){
            self.postMessage({channel:ch,payload:{error:"process decrypt failed: "+e.message}});
          }
        }else{
          self.postMessage({channel:ch,payload});
        }
        return;
      }

      const replyPlain={echo:payload,info:"processed (plain)"};

      if(processKey){
        const enc=await encryptWithKey(JSON.stringify(replyPlain));
        self.postMessage({channel:ch,payload:enc});
      }else{
        self.postMessage({channel:ch,payload:replyPlain});
      }
    };
  `;

  const blob=new Blob([code],{type:"application/javascript"});
  processProxy=new Worker(URL.createObjectURL(blob));
  processStatus.textContent="running";
  log("INFO","Process started");

  processProxy.onmessage=(e)=>{
    const msg=e.data;

    if(msg.type==="key-set"){log("INFO","Process imported key");return;}
    if(msg.type==="key-error"){log("ERROR","Process key import failed");return;}

    IPC.send(msg.channel,msg.payload,{encrypt:false});
  };
};

/* -------------------------------------------------------
   KEY GENERATION
---------------------------------------------------------*/
createKeyBtn.onclick=async()=>{
  setActive(createKeyBtn);
  const password=document.getElementById("pwd").value.trim();
  if(!password){log("ERROR","Enter password first");return;}

  try{
    window._aesKey=await deriveKey(password);
    log("SEC","Key derived in main");

    const raw=await crypto.subtle.exportKey("raw",window._aesKey);

    if(processProxy){
      processProxy.postMessage({type:"set-key",keyRaw:raw},[raw]);
      log("SEC","Key sent to process");
    }
  }catch(e){
    log("ERROR","Key error: "+e.message);
  }
};

/* -------------------------------------------------------
   UI HANDLERS
---------------------------------------------------------*/
const allButtons=[sendBtn,pubBtn,spawnProcessBtn,createKeyBtn,example1,example2,example3,clearBtn];
function setActive(btn){
  allButtons.forEach(b=>b.classList.remove("active-btn"));
  btn.classList.add("active-btn");
}

sendBtn.onclick=async()=>{
  setActive(sendBtn);
  const ch=channelName.value.trim();
  let payload;
  const raw=msgPayload.value.trim();
  try{payload=JSON.parse(raw);}catch{payload=raw;}

  await IPC.send(ch,payload,{encrypt:encryptToggle.checked});
};

pubBtn.onclick=async()=>{
  setActive(pubBtn);
  const ch=channelName.value.trim();
  await IPC.send(ch,{broadcast:true},{encrypt:encryptToggle.checked});
};

example1.onclick=async()=>{
  setActive(example1);
  if(!processProxy){log("ERROR","Start process first");return;}

  const ch=channelName.value.trim();
  const raw=msgPayload.value.trim();
  let payload;
  try{payload=JSON.parse(raw);}catch{payload=raw;}

  if(encryptToggle.checked){
    if(!window._aesKey){log("ERROR","Create key first");return;}
    const enc=await encryptText(window._aesKey,typeof payload==="string"?payload:JSON.stringify(payload));
    processProxy.postMessage({channel:ch,payload:enc});
    log("SENT (enc→process)",enc);
    updateStats(ch);
    return;
  }

  processProxy.postMessage({channel:ch,payload});
  log("SENT→process",payload);
  updateStats(ch);
};

example2.onclick=async()=>{
  setActive(example2);
  IPC.send(channelName.value.trim(),{demo:"broadcast"},{encrypt:encryptToggle.checked});
};

example3.onclick=()=>{
  setActive(example3);
  const ch=channelName.value.trim();
  IPC.on(ch,p=>log("SUB",p));
  log("INFO","Subscribed to "+ch);
};

clearBtn.onclick=()=>{
  setActive(clearBtn);
  logs.innerHTML="";
  log("INFO","Logs cleared");
};

IPC.on("chat",p=>{});
</script>

</body>
</html>
